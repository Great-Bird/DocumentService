[{"title":"Retry","type":0,"sectionRef":"#","url":"/DocumentService/api/Retry","content":"On this page Retry Show Private","keywords":""},{"title":"DocumentService","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentService","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#types","content":" "},{"title":"PreHookEvent​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#PreHookEvent","content":"&lt;/&gt; type PreHookEvent = &quot;Open&quot; | &quot;Close&quot; | &quot;Update&quot; | &quot;Read&quot; Note that Update will run on any operation that saves the datastore e.g. :Save()  "},{"title":"PostHookEvent​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#PostHookEvent","content":"&lt;/&gt; type PostHookEvent = &quot;Open&quot; | &quot;Close&quot; | &quot;Update&quot; | &quot;Read&quot; Note that Update will run on any operation that saves the datastore e.g. :Save()  "},{"title":"FailReason​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#FailReason","content":"&lt;/&gt; type FailReason = &quot;RobloxAPIFail&quot; | &quot;InvalidDataNotHandled&quot; | &quot;SessionLocked&quot; | &quot;MigrationFailed&quot;   "},{"title":"Result<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Result<T>","content":"&lt;/&gt; type Result&lt;T&gt; = ({ success: true, data: T } | { success: false, failReason: FailReason, errorMessage: string, data: nil })   "},{"title":"Migrations<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Migrations<T>","content":"&lt;/&gt; type Migrations&lt;T&gt; = {[number]: (data: unknown) → unknown} This should be a sequential array starting at 1 Data format version start at 0, and the current version is the length of this array. For example, [1] migrates data at format version 0 to format version 1. "},{"title":"DocumentStore","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentStore","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#new","content":"&lt;/&gt; DocumentStore.new( dataStore: DataStore ,-- The object returned by DataStoreService:GetDataStore() check: (unknown) → ( boolean, T ),-- A type check function for your data, errors if types are invalid default: Table&lt;T&gt;,-- Default values, which are set if keys are empty migrations: Migrations&lt;T&gt;-- Fixes invalid data e.g. through migrations. Unfixable data should be reset. ) → DocumentStore Creates a new DocumentStore  "},{"title":"GetDocument​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#GetDocument","content":"&lt;/&gt; DocumentStore.GetDocument( self: DocumentStore&lt;T&gt;, key: string ) → Document Gets the document for the key given, or creates one if it does not exist.  "},{"title":"CloseDocuments​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#CloseDocuments","content":"&lt;/&gt; DocumentStore.CloseDocuments(self: DocumentStore&lt;T&gt;) → () Closes all documents as fast as possible  "},{"title":"isDocumentStore​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#isDocumentStore","content":"&lt;/&gt; DocumentStore.isDocumentStore(instance: metatable) → isDocumentStore-- is it a DocumentStore Checks whether a metatable passed is a DocumentStore "},{"title":"Util","type":0,"sectionRef":"#","url":"/DocumentService/api/Util","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#functions","content":" "},{"title":"uuid​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#uuid","content":"&lt;/&gt; Util.uuid() → ( string, number ) Luau uuid implementation Based off of https://gist.github.com/jrus/3197011  "},{"title":"updateAsync​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#updateAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Util.updateAsync( dataStore: GlobalDataStore , key: string, transform: ( any, DataStoreKeyInfo ) → ( any, {number}?, {}? ) ) → ( boolean, unknown, DataStoreKeyInfo ) A wrapper for UpdateAsync that retries with exponential backoff and prevents use of the throttle 'queue'  "},{"title":"getAsync​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#getAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Util.getAsync( dataStore: GlobalDataStore , key: string ) → ( boolean, unknown, DataStoreKeyInfo ) A wrapper for GetAsync that retries with exponential backoff and prevents use of the throttle 'queue'  "},{"title":"setAsync​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#setAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Util.setAsync( dataStore: GlobalDataStore , key: string, value: any ) → () A wrapper for SetAsync that retries with exponential backoff and prevents use of the throttle 'queue'. I recommend you only use this for edge cases like erasing data.  "},{"title":"deepFreeze​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#deepFreeze","content":"&lt;/&gt; Util.deepFreeze( object: T-- table to freeze ) → frozenTable Deeply freezes a table (not entering metatables)  "},{"title":"assertStorable​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#assertStorable","content":"&lt;/&gt; Util.assertStorable(data: unknown) → () Errors if the data passed is not storable in JSON Rejects: NaN (all numbers must equal themselves) Mixed table index types Non sequential tables indexed by numbers Non-string or number table indexes Cyclic tables type(value) == &quot;userdata&quot; "},{"title":"Document","type":0,"sectionRef":"#","url":"/DocumentService/api/Document","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#functions","content":" "},{"title":"Peek​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Peek","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Peek(self: Document&lt;T&gt;) → Result&lt;any&gt; Reads the data of a potentially locked or unopened Document. Does not update the cache. If the data is not a table or not in the DocumentService format (see KeyData), the data will be nil.  "},{"title":"Open​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Open","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Open(self: Document&lt;T&gt;) → result Validates the document if one exists, or creates a default document if no document exists. You must call this method before reading or writing to a Document. Can fail for the following reasons: RobloxAPIFail or SessionLocked. These should usually be handled by kicking the player.  "},{"title":"Lock​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Lock","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Lock(self: Document&lt;T&gt;) → result Adds a session lock and enables auto-saves. This is a separate method for DX, however unlocking is combined with saving to avoid hitting limits during server shutdowns.  "},{"title":"Close​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Close","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Close(self: Document&lt;T&gt;) → result Destroys the document instance. If session locked, will save the document and remove the lock first.  "},{"title":"SetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#SetCache","content":"&lt;/&gt; Document.SetCache( self: Document&lt;T&gt;, newCache: T ) → newCache Sets the cache. Note you must use immutable operations, i.e. clone any table you intend to edit  "},{"title":"GetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetCache","content":"&lt;/&gt; Document.GetCache(self: Document&lt;T&gt;) → cache Retrieves the cache. Note you must use immutable operations, i.e. clone any table you intend to edit  "},{"title":"UpdateCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#UpdateCache","content":"&lt;/&gt; Document.UpdateCache( self: Document&lt;T&gt;, transform: Transform&lt;T&gt; ) → cache Transforms the cache. Note you must use immutable operations, i.e. clone any table you intend to edit  "},{"title":"Read​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Read","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Read(self: Document&lt;T&gt;) → result-- result containing the data read Reads from the DataStore. warning Overrides the cache. If you are using session locking, you should only read once.  "},{"title":"Update​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Update","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Update( self: Document&lt;T&gt;, transform: Transform&lt;T&gt;,-- Transform function for the transaction. shouldUnlock: boolean?-- Should this update also remove the session lock? This reduces budget usage by combining updates and unlocks. ) → result-- Result containing the new data. Performs an atomic transaction on the Document, writing to the DataStore. If using session locking, transforms will build on cached data.  "},{"title":"Save​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Save","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Save(self: Document&lt;T&gt;) → () Saves a Document's cache to its DataStore. Equivalent to calling Update without transforming the data. For session-locked data only.  "},{"title":"SaveAndUnlock​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#SaveAndUnlock","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.SaveAndUnlock(self: Document&lt;T&gt;) → () Saves a Document's cache to its DataStore and removes the session lock. For session-locked data only.  "},{"title":"Erase​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Erase","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Erase(self: Document&lt;T&gt;) → () Wipes all data associated with the key and closes the document Satisfies compliance with GDPR right of erasure.  "},{"title":"IsLockedByUs​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#IsLockedByUs","content":"&lt;/&gt; Document.IsLockedByUs(self: Document&lt;T&gt;) → boolean Returns whether we hold a session lock on the document and can access caching methods  "},{"title":"HookBefore​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookBefore","content":"&lt;/&gt; Document.HookBefore( self: Document&lt;T&gt;, event: PreHookEvent,-- the operation to call the hook before hook: ((Transform&lt;T&gt;) → Transform&lt;T&gt;) | (() → ())-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs before the event. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added. Explicitly annotate the transform type with DocumentService.Transform to avoid luau typechecking limitations.  "},{"title":"HookAfter​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookAfter","content":"&lt;/&gt; Document.HookAfter( self: Document&lt;T&gt;, event: PostHookEvent,-- the operation to call the hook after hook: (Result&lt;T&gt;) → Result&lt;T&gt;-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs after the event, before the method returns. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added.  "},{"title":"__tostring​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#__tostring","content":"&lt;/&gt; Document.__tostring(self: Document&lt;T&gt;) → () For debug printing documents  "},{"title":"isDocument​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#isDocument","content":"&lt;/&gt; Document.isDocument(instance: metatable) → isDocument-- is it a Document Checks whether a metatable passed is a Document "}]