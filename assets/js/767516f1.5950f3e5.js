"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[556],{57159:e=>{e.exports=JSON.parse('{"functions":[],"properties":[],"types":[{"name":"PreHookEvent","desc":"Runs before the operation.\\n\\nUpdate hooks will run on any operation that saves the datastore e.g. :Save().","lua_type":"\\"Open\\" | \\"Close\\" | \\"Update\\" | \\"Read\\"","source":{"line":12,"path":"src/Types.luau"}},{"name":"PostHookEvent","desc":"Runs after the operation.\\n\\nUpdate hooks will run on any operation that saves the datastore e.g. :Save().","lua_type":"\\"Open\\" | \\"Close\\" | \\"Update\\" | \\"Read\\"","source":{"line":23,"path":"src/Types.luau"}},{"name":"Ok<T>","desc":"Subtype of Result. A success.","lua_type":"{ success: true, data: T }","source":{"line":32,"path":"src/Types.luau"}},{"name":"Err<E>","desc":"Subtype of Result. An error.","lua_type":"{ success: false, reason: E }","source":{"line":44,"path":"src/Types.luau"}},{"name":"Result<T,E>","desc":"The result of a yielding operation that could error. You should always write\\nerror handling for all types of errors that can be returned.","lua_type":"Ok<T> | Err<E>","source":{"line":57,"path":"src/Types.luau"}},{"name":"RobloxAPIError","desc":"Indicates the Roblox API failed, e.g. too many requests","lua_type":"\\"RobloxAPIError\\"","source":{"line":66,"path":"src/Types.luau"}},{"name":"SessionLockedError","desc":"Indicates the document was locked by some other session.","lua_type":"\\"SessionLockedError\\"","source":{"line":75,"path":"src/Types.luau"}},{"name":"CheckError","desc":"Indicates the document\'s check function failed.","lua_type":"\\"CheckError\\"","source":{"line":84,"path":"src/Types.luau"}},{"name":"BackwardsCompatibileError","desc":"Attempted to load data that has been migrated ahead to a version that isn\'t\\nbackwards compatible with the latest version our session has.","lua_type":"\\"BackwardsCompatibleError\\"","source":{"line":94,"path":"src/Types.luau"}},{"name":"SchemaError","desc":"This indicates the key provided is not managed by DocumentService, or has\\nbeen corrupted.\\n\\nThis is for DataStore-requesting methods that can be called before the\\nDocument is opened. In the case of a SchemaError during opening, a new\\nDocument will be created, enclosing the existing value at the key.","lua_type":"\\"SchemaError\\"","source":{"line":108,"path":"src/Types.luau"}},{"name":"Migrations<T>","desc":"Data format versions start at 0. The first migration should migrate from 0 to 1.\\n\\nIf you have data existing in the key before you open a Document, this will be considered version 0 and migrations will run.\\n\\nIf backwardsCompatible is false, loading this version and later versions in an older server without this migration defined will fail.\\n\\nThe current version is defined by the length of this array.","lua_type":"{ { backwardsCompatible: boolean, migrate: (data: any) -> any, } }","source":{"line":124,"path":"src/Types.luau"}},{"name":"Transform<T>","desc":"Takes data and returns an updated version of it.\\nIdeally this should be a pure function.","lua_type":"(data: T) -> T","source":{"line":139,"path":"src/Types.luau"}}],"name":"DocumentService","desc":"Namespace containing public classes and types for DocumentService.\\n\\nContains the classes `DocumentService.DocumentStore` and `DocumentService.SaveUtil`.\\n\\nExample\\n```lua\\n\\tlocal DocumentStore = require(path/to/documentservice).DocumentStore\\n\\tlocal store = DocumentStore.new(...)\\n```","source":{"line":32,"path":"src/init.luau"}}')}}]);