"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[972],{24936:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new Document class\\n\\nDon\'t create more than one Document for the same key, they will be considered different sessions.","params":[{"name":"props","desc":"","lua_type":"DocumentProps"}],"returns":[{"desc":"","lua_type":"Document<T>\\n"}],"function_type":"static","private":true,"source":{"line":232,"path":"src/Document.luau"}},{"name":"Open","desc":"Validates the document if one exists, creates a default document if no\\ndocument exists, or creates a document with the data that is in the given\\nkey if the key hasn\'t been used with DocumentService before.\\n\\nYou must call this method before reading or writing to a Document.\\n\\n:::info\\nIf the document is locked by another session, this method will wait and\\nretry up to 5 times, and yields until the retries are exhausted or the lock\\nis removed. Therefore, you should not use this method to check if the\\nDocument is being used by another session.\\n:::\\n\\n:::warning\\nYou should check the value of `success`, and handle failures by checking\\nthe value of `reason`. The possible `reason`s for each method are defined in\\nthe return type.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"OpenResult<T>"}],"function_type":"static","yields":true,"source":{"line":297,"path":"src/Document.luau"}},{"name":"Steal","desc":"Steals a session lock. This removes any existing lock held by any other\\nsession, and locks the document for ourselves.\\n\\n:::warning\\nDo not use this unless you are certain the previous session is dead, or you\\nwill likely cause data loss.\\nOnly usable on session-locked Documents.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"Result<T, RobloxAPIError | SchemaError>"}],"function_type":"static","yields":true,"source":{"line":444,"path":"src/Document.luau"}},{"name":"IsWriteAvailable","desc":"Returns false if the Document is locked by another session.\\n\\nIf props.sessionLock is false, it will always return true.\\n\\n:::tip\\nYou can use this to check if a player is active to avoid data loss while\\nediting data from another server.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"Result<boolean, RobloxAPIError | SchemaError>"}],"function_type":"static","yields":true,"source":{"line":507,"path":"src/Document.luau"}},{"name":"IsOpen","desc":"Returns whether the document is open or not","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":549,"path":"src/Document.luau"}},{"name":"Close","desc":"Destroys the document instance.\\n\\nIf session locked, will save the document and remove the lock first.\\n\\nAfter closing a Document, you will need to call \\nDocumentStore:GetDocument() to retrieve a new one if you wish to access the\\nDocument again.","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"ReadWriteResult<T?>"}],"function_type":"static","yields":true,"source":{"line":566,"path":"src/Document.luau"}},{"name":"SetCache","desc":"Sets the cache.\\n\\n:::warning\\nYou can only use cache for session-locked data. See `Open` for how to\\nenable session locking.\\n:::\\n\\n:::info\\nYou must use immutable operations on cache, i.e. clone any table you intend to edit.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"},{"name":"newCache","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"T"}],"function_type":"static","source":{"line":606,"path":"src/Document.luau"}},{"name":"GetCache","desc":"Retrieves the cache.\\n\\n:::warning\\nYou can only use cache for session-locked data. See `Open` for how to\\nenable session locking.\\n:::\\n\\n:::info\\nYou must use immutable operations on cache, i.e. clone any table you intend to edit.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"T"}],"function_type":"static","source":{"line":629,"path":"src/Document.luau"}},{"name":"UpdateCache","desc":"Transforms the cache.\\n\\n:::warning\\nYou can only use cache for session-locked data. See `Open` for how to\\nenable session locking.\\n:::\\n\\n:::info\\nYou must use immutable operations on cache, i.e. clone any table you intend to edit.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"},{"name":"transform","desc":"","lua_type":"Transform<T>"}],"returns":[{"desc":"","lua_type":"T"}],"function_type":"static","source":{"line":651,"path":"src/Document.luau"}},{"name":"Read","desc":"Reads from the DataStore.\\n\\n:::warning\\nOverwrites the cache. If you are using session locking, you should only read once.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"ReadWriteResult<T>"}],"function_type":"static","yields":true,"source":{"line":671,"path":"src/Document.luau"}},{"name":"Update","desc":"Performs an atomic transaction on the Document, writing to the DataStore.\\n\\nIf using session locking, transforms will build on cached data.\\n\\nThrows if data is not storable or the transform return value is invalid.\\n\\n:::tip\\nDue to Luau limitations with the old solver, you will get the\\nbest experience if you manually annotate the type of the transform parameter.\\n:::\\n\\n:::warning\\nThe transform function must not yield, and shouldn\'t rely on any\\nfrom outside.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"},{"name":"transform","desc":"Transform function for the transaction.","lua_type":"Transform<T>"}],"returns":[{"desc":"","lua_type":"ReadWriteResult<T>"}],"function_type":"static","yields":true,"source":{"line":734,"path":"src/Document.luau"}},{"name":"Save","desc":"Saves a Document\'s cache to its DataStore. Equivalent to calling Update\\nwithout transforming the data.\\n\\nCan fail due to `RobloxAPIFail` or `SessionLocked` (in the case the lock is stolen).\\n\\n:::warning\\nYou can only use cache for session-locked data. See `Open` for how to\\nenable session locking.\\n:::","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"ReadWriteResult<T>"}],"function_type":"static","yields":true,"source":{"line":853,"path":"src/Document.luau"}},{"name":"Erase","desc":"Wipes all data associated with the key and closes the document.\\n\\nSatisfies compliance with GDPR right of erasure.","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"Result<nil, RobloxAPIError>"}],"function_type":"static","yields":true,"source":{"line":871,"path":"src/Document.luau"}},{"name":"Peek","desc":"Reads the data of a potentially locked or unopened Document.\\n\\nDoes not update the cache.","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[{"desc":"","lua_type":"Result<any, RobloxAPIError | SchemaError>"}],"function_type":"static","yields":true,"source":{"line":896,"path":"src/Document.luau"}},{"name":"HookBefore","desc":"Attaches a hook which occurs before the event.\\n\\nNote that if a hook yields, it will yield all methods that call it. Hooks\\nare called in the order they are added.\\n\\nHooks cannot currently mutate arguments.","params":[{"name":"self","desc":"","lua_type":"Document<T>"},{"name":"event","desc":"the operation to call the hook before","lua_type":"PreHookEvent"},{"name":"hook","desc":"a hook function that receives the arguments passed in to the operation","lua_type":"() -> ()"}],"returns":[],"function_type":"static","source":{"line":934,"path":"src/Document.luau"}},{"name":"HookAfter","desc":"Attaches a hook which occurs after the event, before the method returns.\\n\\nNote that if a hook yields, it will yield all methods that call it. Hooks\\nare called in the order they are added.\\n\\nHooks added with HookAfter only run if the operation is successful, and\\ncannot mutate the result.","params":[{"name":"self","desc":"","lua_type":"Document<T>"},{"name":"event","desc":"the operation to call the hook after","lua_type":"PostHookEvent"},{"name":"hook","desc":"a hook function that receives the arguments passed in to the operation","lua_type":"() -> ()"}],"returns":[],"function_type":"static","source":{"line":950,"path":"src/Document.luau"}},{"name":"__tostring","desc":"","params":[{"name":"self","desc":"","lua_type":"Document<T>"}],"returns":[],"function_type":"static","ignore":true,"source":{"line":957,"path":"src/Document.luau"}},{"name":"isDocument","desc":"Checks if a metatable passed is a Document.","params":[{"name":"instance","desc":"","lua_type":"metatable"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":967,"path":"src/Document.luau"}}],"properties":[],"types":[{"name":"OpenResult<T>","desc":"","lua_type":"Result<T, RobloxAPIError | BackwardsCompatibilityError | CheckError | SessionLockedError>","source":{"line":87,"path":"src/Document.luau"}},{"name":"ReadWriteResult<T>","desc":"","lua_type":"Result<T, RobloxAPIError | SessionLockedError>","source":{"line":94,"path":"src/Document.luau"}},{"name":"DocumentProps","desc":"","fields":[{"name":"key","lua_type":"string","desc":"The datastore key"},{"name":"dataStore","lua_type":"DataStore","desc":"The object returned by DataStoreService:GetDataStore()"},{"name":"check","lua_type":"(unknown) -> (boolean, T)","desc":"A type check function for your data, errors if types are invalid"},{"name":"default","lua_type":"T","desc":"Default values, which are set if keys are empty"},{"name":"migrations","lua_type":"Types.Migrations<T>","desc":"Migrations"},{"name":"sessionLock","lua_type":"boolean","desc":"Should the document be session locked?"}],"private":true,"source":{"line":223,"path":"src/Document.luau"}}],"name":"Document","desc":"An abstraction over keys in a DataStore.\\n\\nDocuments are designed to contain information about an entity in a schema.\\nThis schema is enforced by your check function, and should be changed\\nthrough migrations. You may, of course, decide to not use a schema by\\ndefining an empty check function, but this generally isn\'t recommended.\\n\\n:::tip\\nSession locking prevents your data from being edited by mutliple servers,\\nand ensures one server is finished with it before it is opened by another.\\n\\nIn DocumentService, session locking enables the use of the caching methods\\n`SetCache`, `GetCache`, and `UpdateCache`.\\n\\nThis is ideal for player data, or any data that needs frequent updates\\nand does not need multi-server editing.\\n:::\\n\\n:::warning\\nYou are free to edit the contents of the table in the .data field with\\na tool like DataStore Editor, but manually changing other fields could cause\\ndata loss and errors. You should also take care not to edit any data while\\na Document is open and session locked.\\n:::","source":{"line":39,"path":"src/Document.luau"}}')}}]);