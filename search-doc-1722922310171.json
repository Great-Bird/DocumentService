[{"title":"Retry","type":0,"sectionRef":"#","url":"/DocumentService/api/Retry","content":"On this page Retry Show Private","keywords":""},{"title":"DocumentStore","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentStore","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#new","content":"&lt;/&gt; DocumentStore.new( dataStore: DataStore ,-- The object returned by DataStoreService:GetDataStore() check: (unknown) → ( boolean, T ),-- A type check function for your data, errors if types are invalid default: Table&lt;T&gt;,-- Default values, which are set if keys are empty migrations: Migrations&lt;T&gt;-- Fixes invalid data e.g. through migrations. Unfixable data should be reset. ) → DocumentStore Creates a new DocumentStore warning This should only be called once per server for each DataStore in a live game. If there are multiple instances of a DocumentStore for one key, any Documents will be treated as if they are from different sessions. This is useful for unit testing but can lead to weird bugs in production.  "},{"title":"GetDocument​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#GetDocument","content":"&lt;/&gt; DocumentStore.GetDocument( self: DocumentStore&lt;T&gt;, key: string ) → Document Gets the document for the key given, or creates one if it does not exist.  "},{"title":"CloseAllDocuments​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#CloseAllDocuments","content":"&lt;/&gt; DocumentStore.CloseAllDocuments(self: DocumentStore&lt;T&gt;) → () Closes all documents as fast as possible  "},{"title":"isDocumentStore​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#isDocumentStore","content":"&lt;/&gt; DocumentStore.isDocumentStore(instance: metatable) → isDocumentStore-- is it a DocumentStore Checks whether a metatable passed is a DocumentStore "},{"title":"DocumentService","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentService","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#types","content":" "},{"title":"PreHookEvent​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#PreHookEvent","content":"&lt;/&gt; type PreHookEvent = &quot;Open&quot; | &quot;Close&quot; | &quot;Update&quot; | &quot;Read&quot; Note that Update will run on any operation that saves the datastore e.g. :Save()  "},{"title":"PostHookEvent​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#PostHookEvent","content":"&lt;/&gt; type PostHookEvent = &quot;Open&quot; | &quot;Close&quot; | &quot;Update&quot; | &quot;Read&quot; Note that Update will run on any operation that saves the datastore e.g. :Save()  "},{"title":"FailReason​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#FailReason","content":"&lt;/&gt; type FailReason = &quot;RobloxAPIFail&quot; | &quot;InvalidDataNotHandled&quot; | &quot;SessionLocked&quot; | &quot;MigrationFailed&quot;   "},{"title":"Result<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Result<T>","content":"&lt;/&gt; type Result&lt;T&gt; = ({ success: true, data: T } | { success: false, failReason: FailReason, errorMessage: string, data: nil })   "},{"title":"Migrations<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Migrations<T>","content":"&lt;/&gt; type Migrations&lt;T&gt; = {{ backwardsCompatible: boolean, migrate: (data: unknown) → unknown, }} Data format versions start at 0. The first migration should migrate from 0 to 1. If you have data existing in the key before you open a Document, this will be considered version 0 and migrations will run. If backwardsCompatible is false, loading this version and later versions in an older server without this migration defined will fail. The current version is defined by the length of this array. "},{"title":"Util","type":0,"sectionRef":"#","url":"/DocumentService/api/Util","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#functions","content":" "},{"title":"uuid​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#uuid","content":"&lt;/&gt; Util.uuid() → ( string, number ) Luau uuid implementation Based off of https://gist.github.com/jrus/3197011  "},{"title":"updateAsync​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#updateAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Util.updateAsync( transform: ( any, DataStoreKeyInfo ) → ( any, {number}?, {}? ), dataStore: GlobalDataStore , key: string ) → ( boolean, any, DataStoreKeyInfo ) A wrapper for UpdateAsync that retries with exponential backoff and prevents use of the throttle 'queue'  "},{"title":"getAsync​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#getAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Util.getAsync( dataStore: GlobalDataStore , key: string ) → ( boolean, any, DataStoreKeyInfo ) A wrapper for GetAsync that retries with exponential backoff and prevents use of the throttle 'queue'  "},{"title":"removeAsync​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#removeAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Util.removeAsync( dataStore: GlobalDataStore , key: string ) → boolean A wrapper for RemoveAsync  "},{"title":"deepFreeze​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#deepFreeze","content":"&lt;/&gt; Util.deepFreeze( object: T-- table to freeze ) → frozenTable Deeply freezes a table (not entering metatables)  "},{"title":"assertStorable​","type":1,"pageTitle":"Util","url":"/DocumentService/api/Util#assertStorable","content":"&lt;/&gt; Util.assertStorable(data: unknown) → () Errors if the data passed is not storable in JSON Rejects: NaN (all numbers must equal themselves) Mixed table index types Non sequential tables indexed by numbers Non-string or number table indexes Cyclic tables type(value) == &quot;userdata&quot; "},{"title":"Document","type":0,"sectionRef":"#","url":"/DocumentService/api/Document","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#functions","content":" "},{"title":"Peek​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Peek","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Peek(self: Document&lt;T&gt;) → Result&lt;any&gt; Reads the data of a potentially locked or unopened Document. Does not update the cache. If the data is not a table or not in the DocumentService format (see KeyData), the data will be nil.  "},{"title":"Open​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Open","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Open( self: Document&lt;T&gt;, shouldLock: boolean?-- If true, also session locks the data in the same update ) → result Validates the document if one exists, or creates a default document if no document exists. If shouldLock is true, Open will session lock the document. While this does violate the single responsibility principle, it is far more efficient and safer to do multiple things within one UpdateAsync! You must call this method before reading or writing to a Document. Can fail for the following reasons: RobloxAPIFail, NotBackwardsCompatible, FailedCheck. NotBackwardsCompatible indicates the data has been migrated to a version on a newer server that isn't compatible with this server's latest version. FailedCheck indicates the migrations failed to convert the data to a form that passes the check function and matches the expected type interface. These should usually be handled by kicking the player. warning This method looks at documentServiceFormatVersion to assume the type of values stored in DataStore keys - Data generated by DocumentService is not validated, so if you manually edit anything in keys managed by DocumentService, apart from data, expect errors to be thrown. If a valid version isn't specified, it will assume we are migrating from no library to DocumentService and put the existing contents of the key into the .data field. You are free to edit the contents of the table in the .data field with a tool like DataStore Editor, but corrupting other data could cause your server scripts to break.  "},{"title":"Close​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Close","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Close(self: Document&lt;T&gt;) → result Destroys the document instance. If session locked, will save the document and remove the lock first. Note that after closing a Document, you will need to call DocumentStore:GetDocument() to retrieve a new one if you wish to access the Document again.  "},{"title":"SetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#SetCache","content":"&lt;/&gt; Document.SetCache( self: Document&lt;T&gt;, newCache: T ) → newCache Sets the cache. Note you must use immutable operations, i.e. clone any table you intend to edit  "},{"title":"GetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetCache","content":"&lt;/&gt; Document.GetCache(self: Document&lt;T&gt;) → cache Retrieves the cache. Note you must use immutable operations, i.e. clone any table you intend to edit  "},{"title":"UpdateCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#UpdateCache","content":"&lt;/&gt; Document.UpdateCache( self: Document&lt;T&gt;, transform: Transform&lt;T&gt; ) → cache Transforms the cache. Note you must use immutable operations, i.e. clone any table you intend to edit  "},{"title":"Read​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Read","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Read(self: Document&lt;T&gt;) → result-- result containing the data read Reads from the DataStore. warning Overwrites the cache. If you are using session locking, you should only read once.  "},{"title":"Update​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Update","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Update( self: Document&lt;T&gt;, transform: Transform&lt;T&gt;-- Transform function for the transaction. ) → result-- Result containing the new data. Performs an atomic transaction on the Document, writing to the DataStore. If using session locking, transforms will build on cached data. Note that due to Luau limitations with the old solver, you will have to manually annotate the type of the transform parameter.  "},{"title":"Save​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Save","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Save(self: Document&lt;T&gt;) → () Saves a Document's cache to its DataStore. Equivalent to calling Update without transforming the data. For session-locked data only.  "},{"title":"Erase​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Erase","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Erase(self: Document&lt;T&gt;) → () Wipes all data associated with the key and closes the document Satisfies compliance with GDPR right of erasure.  "},{"title":"IsLockedByUs​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#IsLockedByUs","content":"&lt;/&gt; Document.IsLockedByUs(self: Document&lt;T&gt;) → boolean Returns whether we hold a session lock on the document and can access caching methods  "},{"title":"HookBefore​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookBefore","content":"&lt;/&gt; Document.HookBefore( self: Document&lt;T&gt;, event: PreHookEvent,-- the operation to call the hook before hook: ((Transform&lt;T&gt;) → Transform&lt;T&gt;) | (() → ())-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs before the event. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added. Explicitly annotate the transform type with DocumentService.Transform to avoid luau typechecking limitations.  "},{"title":"HookAfter​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookAfter","content":"&lt;/&gt; Document.HookAfter( self: Document&lt;T&gt;, event: PostHookEvent,-- the operation to call the hook after hook: (Result&lt;T&gt;) → Result&lt;T&gt;-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs after the event, before the method returns. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added.  "},{"title":"__tostring​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#__tostring","content":"&lt;/&gt; Document.__tostring(self: Document&lt;T&gt;) → () For debug printing documents  "},{"title":"isDocument​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#isDocument","content":"&lt;/&gt; Document.isDocument(instance: metatable) → isDocument-- is it a Document Checks whether a metatable passed is a Document "}]