[{"title":"Installation","type":0,"sectionRef":"#","url":"/DocumentService/docs/installation","content":"","keywords":""},{"title":"Method 1: Wally​","type":1,"pageTitle":"Installation","url":"/DocumentService/docs/installation#method-1-wally","content":"Add DocumentService = &quot;anthony0br/documentservice@1.0.0-rc.12&quot; to your wally.toml. "},{"title":"Method 2: Manual​","type":1,"pageTitle":"Installation","url":"/DocumentService/docs/installation#method-2-manual","content":"DocumentService has no dependencies so you can just copy and paste the contents oftarget/roblox into your project. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/DocumentService/docs/intro","content":"","keywords":""},{"title":"Features​","type":1,"pageTitle":"Introduction","url":"/DocumentService/docs/intro#features","content":"Fully strictly typed. This means you get full intellisense and typechecking on your data, and on every API method, including possible errors for each method.Superior Rust-inspired error handling, with each Result for each method providing unique intellisense on which errors you need to handle.Immutable cache and autosaves - preventing bugs caused by updates interfering with eachother.Migrations, inspired by nezuo's Lapis.Validate your data with support for runtime and static typechecking.Documents can be session-locked, or not (to allow multi-server editing).Run hooks before and after operations, e.g. logging.Automatic retry with exponential backoff.Migrate from no library, or another library if you're brave.Checks your data can be stored in JSON to avoid silent errors.Simple API that follows SOLID principles: session-locking a document simply extends the API. For example, in ProfileService you need to provide a lockedHandler function, which changes the behaviour of the method to open a Profile, but in DocumentService you can just use the with :IsWriteAvailable and :Steal methods if you need them.Maintainable, strictly typed source code, that is actively maintained.No dependencies (like Promise). Use whatever abstractions you like, and install easily. See README.md for more. "},{"title":"Migrations","type":0,"sectionRef":"#","url":"/DocumentService/docs/migrations","content":"Migrations There is no example here yet. However, migrations in DocumentService are very similar to migrations in Lapis, which has a good tutorial page here. Have a good example with a well-written explanation? Contribute here!","keywords":""},{"title":"Developer Products","type":0,"sectionRef":"#","url":"/DocumentService/docs/products","content":"Developer Products There is no example here yet. Feel free to make one, oradapt the example from Lapis instead.","keywords":""},{"title":"Waiting for a Document to open","type":0,"sectionRef":"#","url":"/DocumentService/docs/waiting","content":"Waiting for a Document to open A common question I am asked is how to wait for a document to open (on a different thread to the one which called :Open) This is how I do that currently: local thread = coroutine.running() if not document:IsOpen() then document:HookAfter(&quot;Open&quot;, function() if coroutine.status(thread) ~= &quot;suspended&quot; then return end task.defer(thread) end) coroutine.yield() end ","keywords":""},{"title":"Opening a player document","type":0,"sectionRef":"#","url":"/DocumentService/docs/opening","content":"Opening a player document This is an example of how to open a document for a DocumentStore that deals with player data. The following code should run on Players.PlayerAdded: local document = store:GetDocument(tostring(player.UserId)) local result = document:Open() -- DocumentService retries 5 times over 16 seconds, so it is safe to steal -- after a failed `:Open`! if not result.success and result.reason == &quot;SessionLockedError&quot; then document:Steal() result = document:Open() end if not result.success then if result.reason == &quot;BackwardsCompatibilityError&quot; then player:Kick( &quot;You joined an old server which does not support your saved data.&quot; .. &quot;Please try joining another server. If this persists, contact a developer.&quot; ) end if result.reason == &quot;RobloxAPIError&quot; then player:Kick(&quot;Failed to load data due to a Roblox service issue. Try again later.&quot;) end player:Kick( `Failed to load data: {result.reason}. Please screenshot this message and report it to a developer.` ) return false end You should close documents when a player leaves. Note that I have not created a player documents table. You should use :GetDocument to retrieve the document - there is usually no need to create a table to reference your player documents. See the API reference for GetDocument for information on when documents are garbage collected.","keywords":""},{"title":"Creating a DocumentStore","type":0,"sectionRef":"#","url":"/DocumentService/docs/creating","content":"Creating a DocumentStore You need a DocumentStore to get documents to work with! Here's an example of creating one: type DataSchema = { points: number, } local DataInterface = { coins = Guard.Integer, } local function dataCheck(value: unknown): DataSchema assert(type(value) == &quot;table&quot;, &quot;Data must be a table&quot;) local Value: any = value return { coins = DataInterface.coins(Value.coins), } end local store = DocumentStore.new({ dataStore = DataStoreService:GetDataStore(&quot;Test&quot;) :: any, -- For mockDataStores use below! --dataStore = MockDataStore:GetDataStore(&quot;Mock&quot;), check = Guard.Check(dataCheck), default = { coins = 100, }, migrations = {}, lockSessions = true, }) This example uses Guard. You need to cast DataStore to any currently - while this library does dependency inversion properly - Roblox's Luau types don't work well with it! Remember it is important not to create duplicate DocumentStores - they will be treated like separate sessions! If you need to access a DocumentStore from multiple scripts, make sure to create and return it from a module.","keywords":""},{"title":"DocumentStore","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentStore","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#new","content":"&lt;/&gt; DocumentStore.new(props: DocumentStoreProps) → DocumentStore&lt;T&gt; "},{"title":"Types","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore##","content":""},{"title":"​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#DocumentStoreProps","content":"interface DocumentStoreProps { dataStore: DataStore -- The object returned by DataStoreService:GetDataStore() check: (unknown) → ( boolean, T )-- A type check function for your data, errors if types are invalid default: T&amp;{}-- Default values, which are set if keys are empty migrations: Migrations-- Migrations lockSessions: boolean-- Should the documents be session locked? }  Creates a new DocumentStore. warning This should only be called once per server for each DataStore in a live game. If there are multiple instances of a DocumentStore for one key, any Documents will be treated as if they are from different sessions. This is useful for unit testing but can lead to weird bugs in production. DocumentStores should persist through an entire server's lifespan and are not garbage collected.  "},{"title":"GetDocument​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#GetDocument","content":"&lt;/&gt; DocumentStore.GetDocument( self: DocumentStore&lt;T&gt;, key: string ) → ( Document&lt;T&gt;, boolean-- whether a new document was created ) Gets the document for the key given, or creates one if it does not exist. info Documents are cached in a weak table, so once they are closed, they will be marked for garbage collection if you have no references to them. Be careful of references created by closures. Documents that are not session locked will be garbage collected once there are no other references to them.  "},{"title":"CloseAllDocuments​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#CloseAllDocuments","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; DocumentStore.CloseAllDocuments(self: DocumentStore&lt;T&gt;) → () Closes all open documents as fast as possible. This runs on BindToClose already. Will also wait for any documents that are opening to open, and then close them. warning Yields until all documents are closed. If there is a systematic error in your :Close, for example a hook errors, this could infinitely yield. Closes documents asynchronously when request budget allows, and yields all open documents are closed.  "},{"title":"isDocumentStore​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#isDocumentStore","content":"&lt;/&gt; DocumentStore.isDocumentStore(instance: metatable) → boolean Checks if a metatable passed is a DocumentStore. "},{"title":"SaveUtil","type":0,"sectionRef":"#","url":"/DocumentService/api/SaveUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#functions","content":" "},{"title":"assertStorable​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#assertStorable","content":"&lt;/&gt; SaveUtil.assertStorable(data: unknown) → () Errors if the data passed is not storable in JSON Rejects: NaN (all numbers must equal themselves) Mixed table index types Non sequential tables indexed by numbers Non-string or number table indexes Cyclic tables type(value) == &quot;userdata&quot; Functions Metatables Threads Vectors  "},{"title":"uuid​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#uuid","content":"&lt;/&gt; SaveUtil.uuid() → string Luau uuid implementation. Based off of https://gist.github.com/jrus/3197011  "},{"title":"updateAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#updateAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.updateAsync( transform: ( (err: string) → (), unknown, DataStoreKeyInfo ) → ( any, {number}?, {}? ), dataStore: DataStoreInterface, key: string ) → ( boolean, any, DataStoreKeyInfo ) A wrapper for UpdateAsync that retries with exponential backoff, prevents use of the throttle 'queue', and allows retries to be aborted.  "},{"title":"getAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#getAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.getAsync( dataStore: DataStoreInterface, key: string ) → ( boolean, any, DataStoreKeyInfo ) A wrapper for GetAsync that retries with exponential backoff and prevents use of the throttle 'queue'.  "},{"title":"removeAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#removeAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.removeAsync( dataStore: DataStoreInterface, key: string ) → boolean A wrapper for RemoveAsync "},{"title":"DocumentService","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentService","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#types","content":" "},{"title":"HookEvent​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#HookEvent","content":"&lt;/&gt; type HookEvent = &quot;Open&quot; | &quot;Close&quot; | &quot;Update&quot; | &quot;Read&quot; Update hooks will run on any operation that writes to Data Stores e.g. :Save(). Read hooks will run on any operation that reads from Data Stores e.g. :Peek()  "},{"title":"Ok<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Ok<T>","content":"&lt;/&gt; type Ok&lt;T&gt; = { success: true, data: T } Subtype of Result. A success.  "},{"title":"Err<E>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Err<E>","content":"&lt;/&gt; type Err&lt;E&gt; = { success: false, reason: E } Subtype of Result. An error.  "},{"title":"Result<T,E>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Result<T,E>","content":"&lt;/&gt; type Result&lt;T,E&gt; = Ok&lt;T&gt; | Err&lt;E&gt; The result of a yielding operation that could error. You should always write error handling for all types of errors that can be returned.  "},{"title":"RobloxAPIError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#RobloxAPIError","content":"&lt;/&gt; type RobloxAPIError = &quot;RobloxAPIError&quot; Indicates the Roblox API failed, e.g. too many requests  "},{"title":"SessionLockedError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#SessionLockedError","content":"&lt;/&gt; type SessionLockedError = &quot;SessionLockedError&quot; Indicates the document was locked by some other session.  "},{"title":"CheckError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#CheckError","content":"&lt;/&gt; type CheckError = &quot;CheckError&quot; Indicates the document's check function failed.  "},{"title":"BackwardsCompatibilityError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#BackwardsCompatibilityError","content":"&lt;/&gt; type BackwardsCompatibilityError = &quot;BackwardsCompatibleError&quot; Attempted to load data that has been migrated ahead to a version that isn't backwards compatible with the latest version our session has.  "},{"title":"SchemaError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#SchemaError","content":"&lt;/&gt; type SchemaError = &quot;SchemaError&quot; This indicates the key provided is not managed by DocumentService, or has been corrupted. In the case of a SchemaError during opening, a new Document will be created, enclosing the existing value at the key.  "},{"title":"Migrations​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Migrations","content":"&lt;/&gt; type Migrations = {{ backwardsCompatible: boolean, migrate: (data: any) → any, }} Data format versions start at 0. The first migration should migrate from 0 to 1. If you have data existing in the key before you open a Document, this will be considered version 0 and migrations will run. If backwardsCompatible is false, loading this version and later versions in an older server without this migration defined will fail. The current version is defined by the length of this array. warning If you make a not-backwards-compatible migration on not-session-locked Documents, you must shut down all servers, or old servers will break.  "},{"title":"Transform<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Transform<T>","content":"&lt;/&gt; type Transform&lt;T&gt; = (data: T) → T Takes data and returns an updated version of it. Ideally this should be a pure function.  "},{"title":"DataStoreInterface​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#DataStoreInterface","content":"&lt;/&gt; type DataStoreInterface = { UpdateAsync: ( DataStoreInterface, key: string, ( any, DataStoreKeyInfo ) → ( any, {number}?, any? ) ) → ( any, DataStoreKeyInfo ), GetAsync: ( DataStoreInterface, key: string, options: DataStoreGetOptions ) → ( any, DataStoreKeyInfo ), RemoveAsync: ( DataStoreInterface, key: string ) → ( any, DataStoreKeyInfo ) } An interface, implemented by DataStore in Roblox, to allow dependency injection (e.g. MockDataStores). There is currently an issue where passing DataStore will result in a type error, even though DataStore currently implements DataStoreInterface. You can typecast to to any (:: any) as a workaround. "},{"title":"Document","type":0,"sectionRef":"#","url":"/DocumentService/api/Document","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#types","content":" "},{"title":"OpenResult<T>​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OpenResult<T>","content":"&lt;/&gt; type OpenResult&lt;T&gt; = Result&lt;T,RobloxAPIError | BackwardsCompatibilityError | CheckError | SessionLockedError&gt;   "},{"title":"WriteResult<T>​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#WriteResult<T>","content":"&lt;/&gt; type WriteResult&lt;T&gt; = Result&lt;T,RobloxAPIError | SessionLockedError | SchemaError&gt;  "},{"title":"Functions​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#functions","content":" "},{"title":"Open​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Open","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Open(self: Document&lt;T&gt;) → OpenResult&lt;T&gt; Validates the document if one exists, creates a default document if no document exists, or creates a document with the data that is in the given key if the key hasn't been used with DocumentService before. You must call this method before reading or writing to a Document. info If the document is locked by another session, this method will wait and retry up to 5 times, and yields until the retries are exhausted or the lock is removed. Therefore, you should not use this method to check if the Document is being used by another session. warning You should check the value of success, and handle failures by checking the value of reason. The possible reasons for each method are defined in the return type.  "},{"title":"OpenAndUpdate​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OpenAndUpdate","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.OpenAndUpdate( self: Document&lt;T&gt;, transform: Transform&lt;T&gt; ) → OpenResult&lt;T&gt; Opens, and also runs a transform function on the data. Useful for non-session-locked data for shared entities, where one-off updates might be needed. Will throw a Luau error if the transform produces invalid or unsavable data. Runs both Open and Update hooks, including fail hooks.  "},{"title":"Steal​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Steal","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Steal(self: Document&lt;T&gt;) → () Marks the lock as stolen. The next :Open call will ignore any existing locks. info Generally, it is recommended to call :Steal and then :Open in the case that the initial :Open fails due to SessionLockedError. warning Do not use this unless you are very sure the previous session is dead, or you could cause data loss. Only usable on session-locked Documents.  "},{"title":"IsOpenAvailable​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#IsOpenAvailable","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.IsOpenAvailable(self: Document&lt;T&gt;) → Result&lt;boolean,RobloxAPIError&gt; Returns a false Result if Document is currently open, locked by another session, otherwise returns a true Result. If props.lockSessions is false, this will always return a true Result. tip You can use this to check if a player is active to avoid data loss while editing data from another server.  "},{"title":"IsOpen​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#IsOpen","content":"&lt;/&gt; Document.IsOpen(self: Document&lt;T&gt;) → boolean Returns whether the document is open or not  "},{"title":"Close​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Close","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Close(self: Document&lt;T&gt;) → WriteResult&lt;T?&gt; Closes the document, so it cannot be edited. The document must be open before using this method. If session locked, will save the document, remove the lock, and cancel autosaves first. If this fails, the document will not be closed.  "},{"title":"IsClosing​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#IsClosing","content":"&lt;/&gt; Document.IsClosing(self: Document&lt;T&gt;) → boolean Returns true if :Close has been called and is incomplete.  "},{"title":"SetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#SetCache","content":"&lt;/&gt; Document.SetCache( self: Document&lt;T&gt;, newCache: T ) → T Sets the cache. The document must be open before using this method. You can only use cache for session-locked data. warning Your cache should always pass your check function, otherwise autosaves may error. info You must use immutable operations on cache, i.e. clone any table you intend to edit.  "},{"title":"GetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetCache","content":"&lt;/&gt; Document.GetCache(self: Document&lt;T&gt;) → T Retrieves the cache. The document must be open before using this method. You can only use cache for session-locked data. info You must use immutable operations on cache, i.e. clone any table you intend to edit.  "},{"title":"Update​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Update","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Update( self: Document&lt;T&gt;, transform: Transform&lt;T&gt;-- Transform function for the transaction. ) → WriteResult&lt;T&gt; Performs an atomic transaction on the Document, writing to the DataStore. The document must be open before using this method. If using session locking, transforms will build on cached data. Throws if data is not storable or the transform return value is invalid. tip Due to Luau limitations with the old solver, you will get the best experience if you manually annotate the type of the transform parameter. warning The transform function must not yield, and shouldn't rely on any data from outside. It must follow the rules of what is storable in Data Stores. warning Assumes the data that is already in Data Stores is valid since the last:Open. If it isn't, and this is not corrected by the transform, this method will throw a luau error. warning If you are using session locking, your transform needs to use immutable operations (in the same way updating cache does). warning If your transform errors, the update will be aborted and the error will be thrown in a new thread (this is Roblox behaviour). info Unlike Open, this method will not retry if the lock is stolen, and will instead return a SessionLockedError after the first attempt.  "},{"title":"Save​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Save","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Save(self: Document&lt;T&gt;) → WriteResult&lt;T&gt; Saves a Document's cache to its DataStore. Equivalent to calling Update without transforming the data. The document must be open and locked to use this method.  "},{"title":"Erase​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Erase","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Erase(self: Document&lt;T&gt;) → Result&lt;nil,RobloxAPIError&gt; Erases all data associated with the key. The document must not be open. It is up to you to check if the document is open elsewhere, e.g. via IsOpenAvailable. Satisfies compliance with GDPR right of erasure. Does not run hooks.  "},{"title":"Read​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Read","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Read(self: Document&lt;T&gt;) → Result&lt;any,RobloxAPIError | SchemaError | CheckError | BackwardsCompatibilityError&gt; Reads the latest data stored in Data Stores. Runs migrations and the check function, but does not save changes. This may be called while the document is not open. warning A SchemaError will be returned if document has never been opened before, so it is strongly recommended to handle this case, and Open the document before reading it if possible. This includes when migrating from no library. Runs Read hooks.  "},{"title":"HookBefore​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookBefore","content":"&lt;/&gt; Document.HookBefore( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook before hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs before the event. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added. Hooks cannot currently mutate arguments.  "},{"title":"HookAfter​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookAfter","content":"&lt;/&gt; Document.HookAfter( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs after the event, before the method returns. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added. Hooks added with HookAfter only run if the operation is successful, and cannot mutate the result.  "},{"title":"HookFail​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookFail","content":"&lt;/&gt; Document.HookFail( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs after an event fails  "},{"title":"OnceBefore​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OnceBefore","content":"&lt;/&gt; Document.OnceBefore( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook before hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a single-use hook which occurs before the event.  "},{"title":"OnceAfter​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OnceAfter","content":"&lt;/&gt; Document.OnceAfter( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a single-use hook which occurs after the event, before the method returns.  "},{"title":"OnceFail​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OnceFail","content":"&lt;/&gt; Document.OnceFail( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a single-use hook which occurs after an event fails.  "},{"title":"isDocument​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#isDocument","content":"&lt;/&gt; Document.isDocument(instance: metatable) → boolean Checks if a metatable passed is a Document. "}]