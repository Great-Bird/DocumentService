[{"title":"DocumentStore","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentStore","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#new","content":"&lt;/&gt; DocumentStore.new(props: DocumentStoreProps) → DocumentStore "},{"title":"Types","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore##","content":""},{"title":"​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#DocumentStoreProps","content":"interface DocumentStoreProps { dataStore: DataStore -- The object returned by DataStoreService:GetDataStore() check: (unknown) → ( boolean, T )-- A type check function for your data, errors if types are invalid default: T&amp;{}-- Default values, which are set if keys are empty migrations: Migrations&lt;T&gt;-- Migrations sessionLock: boolean-- Should the documents be session locked? }  Creates a new DocumentStore warning This should only be called once per server for each DataStore in a live game. If there are multiple instances of a DocumentStore for one key, any Documents will be treated as if they are from different sessions. This is useful for unit testing but can lead to weird bugs in production.  "},{"title":"GetDocument​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#GetDocument","content":"&lt;/&gt; DocumentStore.GetDocument( self: DocumentStore&lt;T&gt;, key: string ) → Document Gets the document for the key given, or creates one if it does not exist.  "},{"title":"CloseAllDocuments​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#CloseAllDocuments","content":"&lt;/&gt; DocumentStore.CloseAllDocuments(self: DocumentStore&lt;T&gt;) → () Closes all documents as fast as possible. This runs on BindToClose already.  "},{"title":"isDocumentStore​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#isDocumentStore","content":"&lt;/&gt; DocumentStore.isDocumentStore(instance: metatable) → isDocumentStore-- is it a DocumentStore Checks if a metatable passed is a DocumentStore. "},{"title":"SaveUtil","type":0,"sectionRef":"#","url":"/DocumentService/api/SaveUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#functions","content":" "},{"title":"assertStorable​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#assertStorable","content":"&lt;/&gt; SaveUtil.assertStorable(data: unknown) → () Errors if the data passed is not storable in JSON Rejects: NaN (all numbers must equal themselves) Mixed table index types Non sequential tables indexed by numbers Non-string or number table indexes Cyclic tables type(value) == &quot;userdata&quot; Functions Metatables Threads Vectors  "},{"title":"uuid​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#uuid","content":"&lt;/&gt; SaveUtil.uuid() → ( string, number ) Luau uuid implementation Based off of https://gist.github.com/jrus/3197011  "},{"title":"updateAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#updateAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.updateAsync( transform: ( any, DataStoreKeyInfo ) → ( any, {number}?, {}? ), dataStore: GlobalDataStore , key: string ) → ( boolean, any, DataStoreKeyInfo ) A wrapper for UpdateAsync that retries with exponential backoff and prevents use of the throttle 'queue'  "},{"title":"getAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#getAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.getAsync( dataStore: GlobalDataStore , key: string ) → ( boolean, any, DataStoreKeyInfo ) A wrapper for GetAsync that retries with exponential backoff and prevents use of the throttle 'queue'  "},{"title":"removeAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#removeAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.removeAsync( dataStore: GlobalDataStore , key: string ) → boolean A wrapper for RemoveAsync "},{"title":"DocumentService","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentService","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#types","content":" "},{"title":"PreHookEvent​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#PreHookEvent","content":"&lt;/&gt; type PreHookEvent = &quot;Open&quot; | &quot;Close&quot; | &quot;Update&quot; | &quot;Read&quot; Runs before the operation. Update hooks will run on any operation that saves the datastore e.g. :Save().  "},{"title":"PostHookEvent​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#PostHookEvent","content":"&lt;/&gt; type PostHookEvent = &quot;Open&quot; | &quot;Close&quot; | &quot;Update&quot; | &quot;Read&quot; Runs after the operation. Update hooks will run on any operation that saves the datastore e.g. :Save().  "},{"title":"Ok<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Ok<T>","content":"&lt;/&gt; type Ok&lt;T&gt; = { success: true, data: T } Subtype of Result. A success.  "},{"title":"Err<E>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Err<E>","content":"&lt;/&gt; type Err&lt;E&gt; = { success: false, reason: E } Subtype of Result. An error.  "},{"title":"Result<T,E>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Result<T,E>","content":"&lt;/&gt; type Result&lt;T,E&gt; = Ok&lt;T&gt; | Err&lt;E&gt; The result of a yielding operation that could error. You should always write error handling for all types of errors that can be returned.  "},{"title":"RobloxAPIError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#RobloxAPIError","content":"&lt;/&gt; type RobloxAPIError = &quot;RobloxAPIError&quot; Indicates the Roblox API failed, e.g. too many requests  "},{"title":"SessionLockedError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#SessionLockedError","content":"&lt;/&gt; type SessionLockedError = &quot;SessionLockedError&quot; Indicates the document was locked by some other session.  "},{"title":"CheckError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#CheckError","content":"&lt;/&gt; type CheckError = &quot;CheckError&quot; Indicates the document's check function failed.  "},{"title":"BackwardsCompatibileError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#BackwardsCompatibileError","content":"&lt;/&gt; type BackwardsCompatibileError = &quot;BackwardsCompatibleError&quot; Attempted to load data that has been migrated ahead to a version that isn't backwards compatible with the latest version our session has.  "},{"title":"SchemaError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#SchemaError","content":"&lt;/&gt; type SchemaError = &quot;SchemaError&quot; This indicates the key provided is not managed by DocumentService, or has been corrupted. This is for DataStore-requesting methods that can be called before the Document is opened. In the case of a SchemaError during opening, a new Document will be created, enclosing the existing value at the key.  "},{"title":"Migrations<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Migrations<T>","content":"&lt;/&gt; type Migrations&lt;T&gt; = {{ backwardsCompatible: boolean, migrate: (data: any) → any, }} Data format versions start at 0. The first migration should migrate from 0 to 1. If you have data existing in the key before you open a Document, this will be considered version 0 and migrations will run. If backwardsCompatible is false, loading this version and later versions in an older server without this migration defined will fail. The current version is defined by the length of this array.  "},{"title":"Transform<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Transform<T>","content":"&lt;/&gt; type Transform&lt;T&gt; = (data: T) → T Takes data and returns an updated version of it. Ideally this should be a pure function. "},{"title":"Document","type":0,"sectionRef":"#","url":"/DocumentService/api/Document","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#functions","content":" "},{"title":"Open​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Open","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Open(self: Document&lt;T&gt;) → result Validates the document if one exists, creates a default document if no document exists, or creates a document with the data that is in the given key if the key hasn't been used with DocumentService before. You must call this method before reading or writing to a Document. ::info If the document is locked by another session, this method will wait and retry up to 5 times, and yields until the retries are exhausted or the lock is removed. Therefore, you should not use this method to check if the Document is being used by another session. ::: warning You are free to edit the contents of the table in the .data field with a tool like DataStore Editor, but manually changing other fields could cause data loss and errors. You should also take care not to edit any data while a Document is open and session locked. warning You should check the value of success, and handle failures by checking the value of reason. The possible reasons for each method are defined in the return type. tip Session locking prevents your data from being edited by mutliple servers, and ensures one server is finished with it before it is opened by another. In DocumentService, session locking enables the use of the caching methodsSetCache, GetCache, and UpdateCache. This is ideal for player data, or any data that needs frequent updates and does not need multi-server editing. You can enable session locking with the shouldLock argument.  "},{"title":"Close​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Close","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Close(self: Document&lt;T&gt;) → result Destroys the document instance. If session locked, will save the document and remove the lock first. After closing a Document, you will need to call DocumentStore:GetDocument() to retrieve a new one if you wish to access the Document again.  "},{"title":"SetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#SetCache","content":"&lt;/&gt; Document.SetCache( self: Document&lt;T&gt;, newCache: T ) → newCache Sets the cache. warning You can only use cache for session-locked data. See Open for how to enable session locking. info You must use immutable operations on cache, i.e. clone any table you intend to edit.  "},{"title":"GetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetCache","content":"&lt;/&gt; Document.GetCache(self: Document&lt;T&gt;) → cache Retrieves the cache. warning You can only use cache for session-locked data. See Open for how to enable session locking. info You must use immutable operations on cache, i.e. clone any table you intend to edit.  "},{"title":"UpdateCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#UpdateCache","content":"&lt;/&gt; Document.UpdateCache( self: Document&lt;T&gt;, transform: Transform&lt;T&gt; ) → cache Transforms the cache. warning You can only use cache for session-locked data. See Open for how to enable session locking. info You must use immutable operations on cache, i.e. clone any table you intend to edit.  "},{"title":"Read​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Read","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Read(self: Document&lt;T&gt;) → result-- result containing the data read Reads from the DataStore. warning Overwrites the cache. If you are using session locking, you should only read once.  "},{"title":"Update​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Update","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Update( self: Document&lt;T&gt;, transform: Transform&lt;T&gt;-- Transform function for the transaction. ) → result-- Result containing the new data. Performs an atomic transaction on the Document, writing to the DataStore. If using session locking, transforms will build on cached data. Throws if data is not storable or the transform return value is invalid. tip Due to Luau limitations with the old solver, you will get the best experience if you manually annotate the type of the transform parameter. warning The transform function must not yield, and shouldn't rely on any from outside.  "},{"title":"Save​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Save","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Save(self: Document&lt;T&gt;) → ReadWriteResult&lt;T&gt; Saves a Document's cache to its DataStore. Equivalent to calling Update without transforming the data. Can fail due to RobloxAPIFail or SessionLocked (in the case the lock is stolen). warning You can only use cache for session-locked data. See Open for how to enable session locking.  "},{"title":"Erase​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Erase","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Erase(self: Document&lt;T&gt;) → Result&lt;nil,RobloxAPIError&gt; Wipes all data associated with the key and closes the document. Satisfies compliance with GDPR right of erasure.  "},{"title":"Peek​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Peek","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Peek(self: Document&lt;T&gt;) → Result&lt;any,RobloxAPIError | SchemaError&gt; Reads the data of a potentially locked or unopened Document. Does not update the cache.  "},{"title":"HookBefore​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookBefore","content":"&lt;/&gt; Document.HookBefore( self: Document&lt;T&gt;, event: PreHookEvent,-- the operation to call the hook before hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs before the event. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added. Hooks cannot currently mutate arguments.  "},{"title":"HookAfter​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookAfter","content":"&lt;/&gt; Document.HookAfter( self: Document&lt;T&gt;, event: PostHookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a hook which occurs after the event, before the method returns. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added. Hooks added with HookAfter only run if the operation is successful, and cannot mutate the result.  "},{"title":"isDocument​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#isDocument","content":"&lt;/&gt; Document.isDocument(instance: metatable) → isDocument-- is it a Document Checks if a metatable passed is a Document. "}]